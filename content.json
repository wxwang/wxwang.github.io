{"meta":{"title":"vincent's blogs","subtitle":null,"description":null,"author":"vincent","url":"http:","root":"/"},"pages":[{"title":"标签","date":"2019-07-02T13:26:23.000Z","updated":"2019-07-02T13:28:49.985Z","comments":true,"path":"tags/index.html","permalink":"http:/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-02T12:45:01.000Z","updated":"2019-07-02T13:32:34.982Z","comments":true,"path":"categories/index.html","permalink":"http:/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"老男孩python开发-1","slug":"老男孩python开发-1-1","date":"2019-07-03T03:08:31.000Z","updated":"2019-07-03T03:12:14.019Z","comments":true,"path":"2019/07/03/老男孩python开发-1-1/","link":"","permalink":"http:/2019/07/03/老男孩python开发-1-1/","excerpt":"","text":"1.1 计算机硬件基本认知1234cpu: 中央处理器. 相当于人的大脑.运算中心,控制中心.内存: 临时存储数据. 优点:读取速度快。 缺点:容量小,造价高,断电即消失.硬盘: 长期存储数据. 优点:容量大,造价相对低,断电不消失。 缺点:读取速度慢.操作系统:统一管理计算机软硬件资源的程序 python 1.2计算机文件大小单位12345678910b = bit 位(比特)B = Byte 字节1Byte = 8 bit #一个字节等于8位 可以简写成 1B = 8b1KB = 1024B1MB = 1024KB1GB = 1024MB1TB = 1024GB1PB = 1024TB1EB = 1024PB 1.3进制转换1234二进制:由2个数字组成,有0 和 1 例: 0b101 八进制:由8个数字组成,有0,1,2,3,4,5,6,7 例: 0o127 十进制:有10个数字组成,有0,1,2,3,4,5,6,7,8,9 例: 250十六进制:有16个数字组成,有0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f(字母大小写都可以,分别代表10,11,12,13,14,15) 例:0xff 0Xff 0XFF 1.3.1 二进制 转化成 十进制123#例: 0b10100101 运算:1* 2^0 + 0* 2^1 + 1* 2^2 + 0* 2^3 + 0* 2^4 + 1* 2^5 + 0* 2^6 + 1* 2^7= 1 + 0 + 4 + 0 + 0 + 32 + 0 + 128 = 165 1.3.2 八进制 转化成 十进制12#例: 0o127运算:7*8^0 + 2*8^1 + 1*8^2 = 7+16+64 = 87 1.3.3 十六进制 转化成 十进制12#例: 0xff运算:15*16^0 + 15*16^1 = 255 *小练习: 转化成对应进制123456723 =&gt; 2 654 =&gt; 2723 =&gt; 8 654 =&gt; 8723 =&gt; 16 654 =&gt; 16 1.3.4 十进制 转化成 二进制1234426 =&gt; 0b110101010 运算过程: 用426除以2,得出的结果再去不停地除以2, 直到除完最后的结果小于2停止, 在把每个阶段求得的余数从下到上依次拼接完毕即可 1.3.5 十进制 转化成 八进制1234426 =&gt; 0o652运算过程: 用426除以8,得出的结果再去不停地除以8, 直到除完最后的结果小于8停止, 在把每个阶段求得的余数从下到上依次拼接完毕即可 1.3.6 十进制 转化成 十六进制123运算过程: 用426除以16,得出的结果再去不停地除以16, 直到除完最后的结果小于16停止, 在把每个阶段求得的余数从下到上依次拼接完毕即可 *小练习: 转化成对应进制123456723 =&gt; 2 654 =&gt; 2723 =&gt; 8 654 =&gt; 8723 =&gt; 16 654 =&gt; 16 1.3.7 二进制与八进制转换12345678910二进制与八进制对应关系:八进制 二进制0 0001 0012 0103 0114 1005 1016 1107 111 1234例:1010100101八进制:从右向左 3位一隔开 不够三位用0补位 变成:001 010 100 1010o 1 2 4 5 1.3.8 二进制与十六进制转换1234567891011121314151617十六进制 二进制0 00001 00012 00103 00114 01005 01016 01107 01118 10009 1001a 1010b 1011c 1100d 1101e 1110f 1111 1234例:1010100101十六进制:从右向左 4位一隔开 不够四位用0补位 变成:0010 1010 0101 0x2a5 1.3.9 八进制 与 十六进制的转换12先转换成二进制 再去对应转换 比如:0x2a5 转换成 1010100101 再转8进制 0o1245 *小练习: 转化成对应进制12340x1DD =&gt; 8 0x29a =&gt; 80o573 =&gt; 160o336 =&gt; 16 1.4原码,反码,补码1234567891011121314151617181920212223242526# 1.原码 或 补码 都是用来表达二进制数据 原码: 用来转换对应进制 反码: 二进制码0变1,1变0叫做反码,反码用于原码补码之间的转换.(首位符号位不变) 补码: 用来做数据的存储和运算. 补码的提出用于表达一个数的正负（实现减法） 计算机的所有数据在底层都是以二进制的[补码]形式存储 实际上人们看到的数字是[原码]转化来的 [原码] 和 [补码] 可以通过计算互相转化# 2.整体顺序：补码 -&gt; 原码 -&gt; 最后人们看到的数***进制转换的时候需要先把内存存储的补码拿出来变成原码在进行转换输出***# 3.运算规律：原码：正数高位补0 负数高位补1 (前面空白位全是1) 数字1 00000000 1 正数高位第一位补0 数字-1 10000000 1 负数高位第一位补1计算机默认只会做加法,实现减法用负号： 5+(-3) =&gt; 5-3乘法除法:是通过左移和右移 &lt;&lt; &gt;&gt; 来实现# 4.原码 与 反码之间的转换(原码 反码 补码之间的转换 , 符号位不要动)正数: 原码 = 反码 = 补码负数: 原码 = 补码取反加1 给补码求原码负数: 补码 = 原码取反加1 给原码求补码 *小练习：原码 与 反码的转换1234567891011#给原码求补码 -6 的补码是多少? 6 的补码是多少? 10 的补码是多少? -10 的补码是多少? 9 的补码是多少? -9 的补码是多少?#给补码求原码 1 ... 111 00011 (高位都是1) 1 ... 111 0110010 (高位都是1) # 9+(-5) 用二进制相加运算一下","categories":[{"name":"后端","slug":"后端","permalink":"http:/categories/后端/"},{"name":"python","slug":"后端/python","permalink":"http:/categories/后端/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http:/tags/python/"},{"name":"进制转换","slug":"进制转换","permalink":"http:/tags/进制转换/"}]},{"title":"","slug":"老男孩python开发-1","date":"2019-07-03T03:00:22.189Z","updated":"2019-06-23T02:37:11.000Z","comments":true,"path":"2019/07/03/老男孩python开发-1/","link":"","permalink":"http:/2019/07/03/老男孩python开发-1/","excerpt":"","text":"1.1 计算机硬件基本认知1234cpu: 中央处理器. 相当于人的大脑.运算中心,控制中心.内存: 临时存储数据. 优点:读取速度快。 缺点:容量小,造价高,断电即消失.硬盘: 长期存储数据. 优点:容量大,造价相对低,断电不消失。 缺点:读取速度慢.操作系统:统一管理计算机软硬件资源的程序 python 1.2计算机文件大小单位12345678910b = bit 位(比特)B = Byte 字节1Byte = 8 bit #一个字节等于8位 可以简写成 1B = 8b1KB = 1024B1MB = 1024KB1GB = 1024MB1TB = 1024GB1PB = 1024TB1EB = 1024PB 1.3进制转换1234二进制:由2个数字组成,有0 和 1 例: 0b101 八进制:由8个数字组成,有0,1,2,3,4,5,6,7 例: 0o127 十进制:有10个数字组成,有0,1,2,3,4,5,6,7,8,9 例: 250十六进制:有16个数字组成,有0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f(字母大小写都可以,分别代表10,11,12,13,14,15) 例:0xff 0Xff 0XFF 1.3.1 二进制 转化成 十进制123#例: 0b10100101 运算:1* 2^0 + 0* 2^1 + 1* 2^2 + 0* 2^3 + 0* 2^4 + 1* 2^5 + 0* 2^6 + 1* 2^7= 1 + 0 + 4 + 0 + 0 + 32 + 0 + 128 = 165 1.3.2 八进制 转化成 十进制12#例: 0o127运算:7*8^0 + 2*8^1 + 1*8^2 = 7+16+64 = 87 1.3.3 十六进制 转化成 十进制12#例: 0xff运算:15*16^0 + 15*16^1 = 255 *小练习: 转化成对应进制123456723 =&gt; 2 654 =&gt; 2723 =&gt; 8 654 =&gt; 8723 =&gt; 16 654 =&gt; 16 1.3.4 十进制 转化成 二进制1234426 =&gt; 0b110101010 运算过程: 用426除以2,得出的结果再去不停地除以2, 直到除完最后的结果小于2停止, 在把每个阶段求得的余数从下到上依次拼接完毕即可 1.3.5 十进制 转化成 八进制1234426 =&gt; 0o652运算过程: 用426除以8,得出的结果再去不停地除以8, 直到除完最后的结果小于8停止, 在把每个阶段求得的余数从下到上依次拼接完毕即可 1.3.6 十进制 转化成 十六进制123运算过程: 用426除以16,得出的结果再去不停地除以16, 直到除完最后的结果小于16停止, 在把每个阶段求得的余数从下到上依次拼接完毕即可 *小练习: 转化成对应进制123456723 =&gt; 2 654 =&gt; 2723 =&gt; 8 654 =&gt; 8723 =&gt; 16 654 =&gt; 16 1.3.7 二进制与八进制转换12345678910二进制与八进制对应关系:八进制 二进制0 0001 0012 0103 0114 1005 1016 1107 111 1234例:1010100101八进制:从右向左 3位一隔开 不够三位用0补位 变成:001 010 100 1010o 1 2 4 5 1.3.8 二进制与十六进制转换1234567891011121314151617十六进制 二进制0 00001 00012 00103 00114 01005 01016 01107 01118 10009 1001a 1010b 1011c 1100d 1101e 1110f 1111 1234例:1010100101十六进制:从右向左 4位一隔开 不够四位用0补位 变成:0010 1010 0101 0x2a5 1.3.9 八进制 与 十六进制的转换12先转换成二进制 再去对应转换 比如:0x2a5 转换成 1010100101 再转8进制 0o1245 *小练习: 转化成对应进制12340x1DD =&gt; 8 0x29a =&gt; 80o573 =&gt; 160o336 =&gt; 16 1.4原码,反码,补码1234567891011121314151617181920212223242526# 1.原码 或 补码 都是用来表达二进制数据 原码: 用来转换对应进制 反码: 二进制码0变1,1变0叫做反码,反码用于原码补码之间的转换.(首位符号位不变) 补码: 用来做数据的存储和运算. 补码的提出用于表达一个数的正负（实现减法） 计算机的所有数据在底层都是以二进制的[补码]形式存储 实际上人们看到的数字是[原码]转化来的 [原码] 和 [补码] 可以通过计算互相转化# 2.整体顺序：补码 -&gt; 原码 -&gt; 最后人们看到的数***进制转换的时候需要先把内存存储的补码拿出来变成原码在进行转换输出***# 3.运算规律：原码：正数高位补0 负数高位补1 (前面空白位全是1) 数字1 00000000 1 正数高位第一位补0 数字-1 10000000 1 负数高位第一位补1计算机默认只会做加法,实现减法用负号： 5+(-3) =&gt; 5-3乘法除法:是通过左移和右移 &lt;&lt; &gt;&gt; 来实现# 4.原码 与 反码之间的转换(原码 反码 补码之间的转换 , 符号位不要动)正数: 原码 = 反码 = 补码负数: 原码 = 补码取反加1 给补码求原码负数: 补码 = 原码取反加1 给原码求补码 *小练习：原码 与 反码的转换1234567891011#给原码求补码 -6 的补码是多少? 6 的补码是多少? 10 的补码是多少? -10 的补码是多少? 9 的补码是多少? -9 的补码是多少?#给补码求原码 1 ... 111 00011 (高位都是1) 1 ... 111 0110010 (高位都是1) # 9+(-5) 用二进制相加运算一下","categories":[],"tags":[]},{"title":"老男孩python开发","slug":"老男孩python开发-2","date":"2019-07-02T14:03:57.000Z","updated":"2019-07-03T03:14:08.988Z","comments":true,"path":"2019/07/02/老男孩python开发-2/","link":"","permalink":"http:/2019/07/02/老男孩python开发-2/","excerpt":"","text":"python 简介 注释 变量 数据类型 运算符 缓存机制2.1python认知 12345678910111213141516171819202122232425262728293031# ### (1)python 简介 89年开发的语言,创始人范罗苏姆(Guido van Rossum),别称:龟叔(Guido). python具有非常多并且强大的第三方库,使得程序开发起来得心应手. Python程序员的信仰:人生苦短,我用python! 开发方向： 机器学习人工智能 ，自动化运维&amp;测试 ，数据分析&amp;爬虫 ，python全栈开发 # ### (2)python 版本 python 2.x 版本，官方在 2020 年停止支持,原码不规范,重复较多 python 3.x 版本，功能更加强大且修复了很多bug,原码清晰,简单# ### (3)编译型与解释型语言区别: 编译型:一次性,把所有代码编译成机器能识别的二进制码,在运行 代表语言:c,c++ 优点: 执行速度块 缺点: 开发速度慢,调试周期长 解释型:代码从上到下一行一行解释并运行 代表语言:python,php 优点: 开发效率快,调试周期短 缺点: 执行速度相对慢 *linux 操作系统默认支持python语言，可直接使用# ### (4)python的解释器: (1)Cpython(官方推荐) 把python转化成c语言能识别的二进制码 (2)Jpython 把python转化成java语言能识别的二进制码 (3)其他语言解释器 把python转化成其他语言能识别的二进制码 (4)PyPy 将所有代码一次性编译成二进制码,加快执行效率(模仿编译型语言的一款python解释器) 2.2注释: 就是对代码的解释 方便大家阅读python代码123(1)注释的分类(2)注释的注意点(3)注释的排错性 123456789101112131415(1)注释的分类 ： 1.单行注释 2.多行注释 # 1.单行注释 以#号开头 ，右边的所有东西都被当做说明文字 ，程序不进行编译运行。 print(‘hello world’) # 2.多行注释 三个单引号 或 三个双引号 ''' 这是第一行 这是第二行 ''' (2)注释的注意点 如果外面使用三个单引号，里面使用三个双引号，反之亦然。(3)注释的排错性 先注释一部分代码，然后执行另外一部分，看看是否报错，逐层缩小报错范围，找到最终错误点。 2.3变量: 可以改变的量,实际具体指的是内存中的一块存储空间1234567(1)变量的概念(2)变量的声明(3)变量的命名(4)变量的交换* 常量就是不可改变的量,python当中没有明确定义常量的关键字, 所以约定俗成把变量名大写就是常量,表示不可改变 1234567891011(1)变量的概念: 可以改变的量就是变量。具体指代的是内存的一块空间(2)变量的声明: #1. a = 1 , b = 2 #2. a,b = 1,2 #3. a = b = 3(3)变量的命名: #字母数字下划线 ，首字符不能为数字 #严格区分大小写 ，且不能使用关键字 #变量命名有意义 ，且不能使用中文哦(4)变量的交换: #a,b = b,a 2.4python六大标准数据类型:1234567891011121314151617181920# ### 数据类型分类：(1)Number 数字类型 (int float bool complex)(2)str 字符串类型 (3)list 列表类型 (4)tuple 元组类型 (5)set 集合类型 (6)dict 字典类型 # ### Number数字类型分类：int : 整数类型 ( 正整数 0 负整数 )float: 浮点数类型 ( 1普通小数 2科学计数法表示的小数 例:a = 3e-5 #3e-05 )bool: 布尔值类型 ( 真True 和 假False )complex: 复数类型 ( 声明复数的2种方法 ) (复数用作于科学计算中,表示高精度的数据,科学家会使用) # ### 容器类型分类：五个str \"nihao\"list [1,2,3]tuple (6，7，8)set &#123;'a',1,2&#125;dict &#123;'a':1,'b':2&#125; 2.4.1自动类型转换12当2个不同类型的数据进行运算的时候,默认向更高精度转换数据类型精度从低到高: bool int float complex 2.4.2强制类型转换12345# --&gt;Number部分int : 整型 浮点型 布尔类型 纯数字字符串float: 整型 浮点型 布尔类型 纯数字字符串complex: 整型 浮点型 布尔类型 纯数字字符串 (复数)bool: ( 容器类型数据 / Number类型数据 都可以 ) 123456# --&gt;容器类型部分str: ( 容器类型数据 / Number类型数据 都可以 )list: 字符串 列表 元组 集合 字典tuple: 字符串 列表 元组 集合 字典set: 字符串 列表 元组 集合 字典 (注意:相同的值,只会保留一份)dict: 使用 二级列表,二级元组,二级集合(里面的容器数据只能是元组) 2.4.3字典和集合的注意点123456789101112131415161718192021222324252627# ###哈希算法#定义: 把不可变的任意长度值计算成固定长度的唯一值,这个值可正可负,可大可小,但长度固定 该算法叫哈希算法(散列算法)，这个固定长度值叫哈希值(散列值) #特点: 1.计算出来的值长度固定且该值唯一 2.该字符串是密文，且加密过程不可逆 #用哈希计算得到一个字符串的用意？ 例如：比对两个文件的内容是否一致？ 例如：比对输入的密码和数据库存储的密码是否一致 #字典的键和集合中的值都是唯一值,不可重复: 为了保证数据的唯一性， 用哈希算法加密字典的键得到一个字符串。 用哈希算法加密集合的值得到一个字符串。 如果重复，他们都是后面的替换前面的。自动去重 #版本: 3.6版本之前都是 字典和集合都是无序的 3.6版本之后,把字典的字面顺序记录下来，当从内存拿数据的时候， 根据字面顺序重新排序，所以看起来像有序,但本质上无序可哈希数据:可哈希的数据 (不可变的数据)：Number(int float bool complex) str tuple不可哈希的数据 (可变的数据)： list set dict 2.5python运算符1234567(1)算数运算符: + - * / // % **(2)比较运算符: &gt; &lt; &gt;= &lt;= == != (3)赋值运算符: = += -= *= /= //= %= **=(4)成员运算符: in 和 not in (针对于容器型数据)(5)身份运算符: is 和 is not (检测两个数据在内存当中是否是同一个值) (6)逻辑运算符: and or not(7)位运算符: &amp; | ~ ^ &lt;&lt; &gt;&gt; python运算符 注意点 算数运算符 % 取余 ， //地板除 ， ** 幂运算 比较运算符 == 比较两个值是否相等 != 比较两个值是否不同 赋值运算符 a += 1 =&gt; a = a+1 成员运算符 in 或 not in 判断某个值是否包含在(或不在)一个容器类型数据当中 身份运算符 is 和 is not 用来判断内存地址是否相同 逻辑运算符 优先级 () &gt; not &gt; and &gt; or 位运算符 优先级 (&lt;&lt;或 &gt;&gt; ) &gt; &amp; &gt; ^ &gt; \\ 5 &lt;&lt; 1 结果：10 , 5 &gt;&gt; 1 结果：2 2.6数据在内存中的缓存机制2.6.1在同一文件(模块)里,变量存储的缓存机制 (仅对python3.6版本负责)12345# --&gt;Number 部分1.对于整型而言，-5~正无穷范围内的相同值 id一致2.对于浮点数而言，非负数范围内的相同值 id一致3.布尔值而言,值相同情况下，id一致4.复数在 实数+虚数 这样的结构中永不相同(只有虚数的情况例外) 123# --&gt;容器类型部分5.字符串 和 空元组 相同的情况下，地址相同6.列表，元组，字典，集合无论什么情况 id标识都不同 [空元组例外] 2.6.2不同文件(模块)里,部分数据驻留小数据池中 (仅对python3.6版本负责 了解)12345小数据池只针对：int,str,bool，空元祖(),None关键字 这些数据类型有效#(1)对于int而言 python在内存中创建了-5 ~ 256 范围的整数,提前驻留在了内存的一块区域. 如果是不同文件(模块)的两个变量,声明同一个值，在-5~256这个范围里， 那么id一致.让两个变量的值都同时指向一个值的地址，节省空间。 12#(2)对于str来说: 1.字符串的长度为0或者1，默认驻留小数据池 12.字符串的长度&gt;1,且只含有大小写字母，数字，下划线时，默认驻留小数据池 1233.用*号得到的字符串，分两种情况。 1)乘数等于1时: 无论什么字符串 * 1 , 都默认驻留小数据池 2)乘数大于1时: 乘数大于1，仅包含数字，字母，下划线时会被缓存，但字符串长度不能大于20 1234567#（3）指定驻留 # 从 sys模块 引入 intern 函数 让a，b两个变量指向同一个值 from sys import intern a = intern('大帅锅&amp;*^^1234'*10) b = intern('大帅锅&amp;*^^1234'*10) print(a is b)#可以指定任意字符串加入到小数据池中,无论声明多少个变量,只要此值相同,都指向同一个地址空间 2.6.3 缓存机制的意义1无论是变量缓存机制还是小数据池的驻留机制,都是为了节省内存空间,提升代码效率","categories":[{"name":"后端","slug":"后端","permalink":"http:/categories/后端/"},{"name":"python","slug":"后端/python","permalink":"http:/categories/后端/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http:/tags/python/"},{"name":"解释器","slug":"解释器","permalink":"http:/tags/解释器/"},{"name":"变量","slug":"变量","permalink":"http:/tags/变量/"},{"name":"数据类型","slug":"数据类型","permalink":"http:/tags/数据类型/"},{"name":"运算符","slug":"运算符","permalink":"http:/tags/运算符/"}]},{"title":"","slug":"老男孩python","date":"2019-07-02T14:02:04.544Z","updated":"2019-07-02T14:08:46.871Z","comments":true,"path":"2019/07/02/老男孩python/","link":"","permalink":"http:/2019/07/02/老男孩python/","excerpt":"","text":"2.1python认知 12345678910111213141516171819202122232425262728293031# ### (1)python 简介 89年开发的语言,创始人范罗苏姆(Guido van Rossum),别称:龟叔(Guido). python具有非常多并且强大的第三方库,使得程序开发起来得心应手. Python程序员的信仰:人生苦短,我用python! 开发方向： 机器学习人工智能 ，自动化运维&amp;测试 ，数据分析&amp;爬虫 ，python全栈开发 # ### (2)python 版本 python 2.x 版本，官方在 2020 年停止支持,原码不规范,重复较多 python 3.x 版本，功能更加强大且修复了很多bug,原码清晰,简单# ### (3)编译型与解释型语言区别: 编译型:一次性,把所有代码编译成机器能识别的二进制码,在运行 代表语言:c,c++ 优点: 执行速度块 缺点: 开发速度慢,调试周期长 解释型:代码从上到下一行一行解释并运行 代表语言:python,php 优点: 开发效率快,调试周期短 缺点: 执行速度相对慢 *linux 操作系统默认支持python语言，可直接使用# ### (4)python的解释器: (1)Cpython(官方推荐) 把python转化成c语言能识别的二进制码 (2)Jpython 把python转化成java语言能识别的二进制码 (3)其他语言解释器 把python转化成其他语言能识别的二进制码 (4)PyPy 将所有代码一次性编译成二进制码,加快执行效率(模仿编译型语言的一款python解释器) 2.2注释: 就是对代码的解释 方便大家阅读python代码123(1)注释的分类(2)注释的注意点(3)注释的排错性 123456789101112131415(1)注释的分类 ： 1.单行注释 2.多行注释 # 1.单行注释 以#号开头 ，右边的所有东西都被当做说明文字 ，程序不进行编译运行。 print(‘hello world’) # 2.多行注释 三个单引号 或 三个双引号 ''' 这是第一行 这是第二行 ''' (2)注释的注意点 如果外面使用三个单引号，里面使用三个双引号，反之亦然。(3)注释的排错性 先注释一部分代码，然后执行另外一部分，看看是否报错，逐层缩小报错范围，找到最终错误点。 2.3变量: 可以改变的量,实际具体指的是内存中的一块存储空间1234567(1)变量的概念(2)变量的声明(3)变量的命名(4)变量的交换* 常量就是不可改变的量,python当中没有明确定义常量的关键字, 所以约定俗成把变量名大写就是常量,表示不可改变 1234567891011(1)变量的概念: 可以改变的量就是变量。具体指代的是内存的一块空间(2)变量的声明: #1. a = 1 , b = 2 #2. a,b = 1,2 #3. a = b = 3(3)变量的命名: #字母数字下划线 ，首字符不能为数字 #严格区分大小写 ，且不能使用关键字 #变量命名有意义 ，且不能使用中文哦(4)变量的交换: #a,b = b,a 2.4python六大标准数据类型:1234567891011121314151617181920# ### 数据类型分类：(1)Number 数字类型 (int float bool complex)(2)str 字符串类型 (3)list 列表类型 (4)tuple 元组类型 (5)set 集合类型 (6)dict 字典类型 # ### Number数字类型分类：int : 整数类型 ( 正整数 0 负整数 )float: 浮点数类型 ( 1普通小数 2科学计数法表示的小数 例:a = 3e-5 #3e-05 )bool: 布尔值类型 ( 真True 和 假False )complex: 复数类型 ( 声明复数的2种方法 ) (复数用作于科学计算中,表示高精度的数据,科学家会使用) # ### 容器类型分类：五个str \"nihao\"list [1,2,3]tuple (6，7，8)set &#123;'a',1,2&#125;dict &#123;'a':1,'b':2&#125; 2.4.1自动类型转换12当2个不同类型的数据进行运算的时候,默认向更高精度转换数据类型精度从低到高: bool int float complex 2.4.2强制类型转换12345# --&gt;Number部分int : 整型 浮点型 布尔类型 纯数字字符串float: 整型 浮点型 布尔类型 纯数字字符串complex: 整型 浮点型 布尔类型 纯数字字符串 (复数)bool: ( 容器类型数据 / Number类型数据 都可以 ) 123456# --&gt;容器类型部分str: ( 容器类型数据 / Number类型数据 都可以 )list: 字符串 列表 元组 集合 字典tuple: 字符串 列表 元组 集合 字典set: 字符串 列表 元组 集合 字典 (注意:相同的值,只会保留一份)dict: 使用 二级列表,二级元组,二级集合(里面的容器数据只能是元组) 2.4.3字典和集合的注意点123456789101112131415161718192021222324252627# ###哈希算法#定义: 把不可变的任意长度值计算成固定长度的唯一值,这个值可正可负,可大可小,但长度固定 该算法叫哈希算法(散列算法)，这个固定长度值叫哈希值(散列值) #特点: 1.计算出来的值长度固定且该值唯一 2.该字符串是密文，且加密过程不可逆 #用哈希计算得到一个字符串的用意？ 例如：比对两个文件的内容是否一致？ 例如：比对输入的密码和数据库存储的密码是否一致 #字典的键和集合中的值都是唯一值,不可重复: 为了保证数据的唯一性， 用哈希算法加密字典的键得到一个字符串。 用哈希算法加密集合的值得到一个字符串。 如果重复，他们都是后面的替换前面的。自动去重 #版本: 3.6版本之前都是 字典和集合都是无序的 3.6版本之后,把字典的字面顺序记录下来，当从内存拿数据的时候， 根据字面顺序重新排序，所以看起来像有序,但本质上无序可哈希数据:可哈希的数据 (不可变的数据)：Number(int float bool complex) str tuple不可哈希的数据 (可变的数据)： list set dict 2.5python运算符1234567(1)算数运算符: + - * / // % **(2)比较运算符: &gt; &lt; &gt;= &lt;= == != (3)赋值运算符: = += -= *= /= //= %= **=(4)成员运算符: in 和 not in (针对于容器型数据)(5)身份运算符: is 和 is not (检测两个数据在内存当中是否是同一个值) (6)逻辑运算符: and or not(7)位运算符: &amp; | ~ ^ &lt;&lt; &gt;&gt; python运算符 注意点 算数运算符 % 取余 ， //地板除 ， ** 幂运算 比较运算符 == 比较两个值是否相等 != 比较两个值是否不同 赋值运算符 a += 1 =&gt; a = a+1 成员运算符 in 或 not in 判断某个值是否包含在(或不在)一个容器类型数据当中 身份运算符 is 和 is not 用来判断内存地址是否相同 逻辑运算符 优先级 () &gt; not &gt; and &gt; or 位运算符 优先级 (&lt;&lt;或 &gt;&gt; ) &gt; &amp; &gt; ^ &gt; \\ 5 &lt;&lt; 1 结果：10 , 5 &gt;&gt; 1 结果：2 2.6数据在内存中的缓存机制2.6.1在同一文件(模块)里,变量存储的缓存机制 (仅对python3.6版本负责)12345# --&gt;Number 部分1.对于整型而言，-5~正无穷范围内的相同值 id一致2.对于浮点数而言，非负数范围内的相同值 id一致3.布尔值而言,值相同情况下，id一致4.复数在 实数+虚数 这样的结构中永不相同(只有虚数的情况例外) 123# --&gt;容器类型部分5.字符串 和 空元组 相同的情况下，地址相同6.列表，元组，字典，集合无论什么情况 id标识都不同 [空元组例外] 2.6.2不同文件(模块)里,部分数据驻留小数据池中 (仅对python3.6版本负责 了解)12345小数据池只针对：int,str,bool，空元祖(),None关键字 这些数据类型有效#(1)对于int而言 python在内存中创建了-5 ~ 256 范围的整数,提前驻留在了内存的一块区域. 如果是不同文件(模块)的两个变量,声明同一个值，在-5~256这个范围里， 那么id一致.让两个变量的值都同时指向一个值的地址，节省空间。 12#(2)对于str来说: 1.字符串的长度为0或者1，默认驻留小数据池 12.字符串的长度&gt;1,且只含有大小写字母，数字，下划线时，默认驻留小数据池 1233.用*号得到的字符串，分两种情况。 1)乘数等于1时: 无论什么字符串 * 1 , 都默认驻留小数据池 2)乘数大于1时: 乘数大于1，仅包含数字，字母，下划线时会被缓存，但字符串长度不能大于20 1234567#（3）指定驻留 # 从 sys模块 引入 intern 函数 让a，b两个变量指向同一个值 from sys import intern a = intern('大帅锅&amp;*^^1234'*10) b = intern('大帅锅&amp;*^^1234'*10) print(a is b)#可以指定任意字符串加入到小数据池中,无论声明多少个变量,只要此值相同,都指向同一个地址空间 2.6.3 缓存机制的意义1无论是变量缓存机制还是小数据池的驻留机制,都是为了节省内存空间,提升代码效率","categories":[],"tags":[]},{"title":"jQuery表单验证","slug":"hello-world","date":"2019-07-02T02:58:20.881Z","updated":"2019-07-02T13:40:41.652Z","comments":true,"path":"2019/07/02/hello-world/","link":"","permalink":"http:/2019/07/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"前端","slug":"前端","permalink":"http:/categories/前端/"},{"name":"jQuery","slug":"前端/jQuery","permalink":"http:/categories/前端/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http:/tags/jQuery/"},{"name":"表格","slug":"表格","permalink":"http:/tags/表格/"},{"name":"表单验证","slug":"表单验证","permalink":"http:/tags/表单验证/"}]}]}